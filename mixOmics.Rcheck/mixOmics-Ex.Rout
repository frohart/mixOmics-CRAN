
R version 3.1.0 (2014-04-10) -- "Spring Dance"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin10.8.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "mixOmics"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "mixOmics-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('mixOmics')
Loading required package: MASS
Warning: package ‘MASS’ was built under R version 3.1.1
Loading required package: lattice
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("cim")
> ### * cim
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cim
> ### Title: Clustered Image Maps (CIMs) ("heat maps")
> ### Aliases: cim cim.default cim.rcc cim.spls cim.pls
> ### Keywords: multivariate iplot hplot graphs cluster
> 
> ### ** Examples
> 
> ## default method
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> 
> cim(cor(X, Y), dendrogram = "none")
> 
> ## CIM representation for objects of class 'rcc'
> nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
> 
> dends <- cim(nutri.res, comp = 1:3, xlab = "genes", 
+              ylab = "lipids", margins = c(5, 6))
> 
> op <- par(mar = c(5, 4, 4, 4), cex = 0.8)			 
> plot(dends$ddr, axes = FALSE, horiz = TRUE)
> par(op)
> 
> ## interactive 'zoom' 
> ## Not run: 
> ##D cim(nutri.res, comp = 1:3, zoom = TRUE)
> ##D ## select the region and "see" the zoom-out region
> ## End(Not run)
> 
> ## CIM representation for objects of class 'spls'
> data(liver.toxicity)
> X <- liver.toxicity$gene
> Y <- liver.toxicity$clinic
> 
> toxicity.spls <- spls(X, Y, ncomp = 3, keepX = c(50, 50, 50), 
+                       keepY = c(10, 10, 10))
> 
> cim(toxicity.spls, comp = 1:3)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cim", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("color.jet")
> ### * color.jet
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: color.jet
> ### Title: Color Palette for mixOmics
> ### Aliases: color.jet color.spectral color.GreenRed color.mixo
> ### Keywords: color
> 
> ### ** Examples
> 
> # -----------------------
> # jet colors
> # ----------------------
> par(mfrow = c(3, 1))
> z <- seq(-1, 1, length = 125)
> for (n in c(11, 33, 125)) {
+   image(matrix(z, ncol = 1), col = color.jet(n), 
+         xaxt = 'n', yaxt = 'n', main = paste('n = ', n))
+   box()
+   par(usr = c(-1, 1, -1, 1))    
+   axis(1, at = c(-1, 0, 1))
+ }
> 
> # -----------------------
> # spectral colors
> # ----------------------
> par(mfrow = c(3, 1))
> z <- seq(-1, 1, length = 125)
> for (n in c(11, 33, 125)) {
+   image(matrix(z, ncol = 1), col = color.spectral(n), 
+         xaxt = 'n', yaxt = 'n', main = paste('n = ', n))
+   box()
+   par(usr = c(-1, 1, -1, 1))    
+   axis(1, at = c(-1, 0, 1))
+ }
> 
> # -----------------------
> # GreenRed colors
> # ----------------------
> par(mfrow = c(3, 1))
> z <- seq(-1, 1, length = 125)
> for (n in c(11, 33, 125)) {
+   image(matrix(z, ncol = 1), col = color.GreenRed(n), 
+         xaxt = 'n', yaxt = 'n', main = paste('n = ', n))
+   box()
+   par(usr = c(-1, 1, -1, 1))    
+   axis(1, at = c(-1, 0, 1))
+ }
> 
> # # --------------------------------
> # mixOmics colors
> # # -------------------------------
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
> 
> my.colors = color.mixo(as.numeric(nutrimouse$diet))
> my.pch = ifelse(nutrimouse$genotype == 'wt', 16, 17)
> plotIndiv(nutri.res, ind.names = FALSE, col = my.colors, pch = my.pch, cex = 1.5)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("color.jet", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("image.tune.rcc")
> ### * image.tune.rcc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: image
> ### Title: Plot the cross-validation score.
> ### Aliases: image.tune.rcc
> ### Keywords: dplot hplot
> 
> ### ** Examples
> 
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> 
> ## this can take some seconds
> cv.score <- tune.rcc(X, Y, validation = "Mfold", plt = FALSE)
  lambda1 =  0.001 
  lambda2 =  0.25075 
 CV-score =  0.5962799 
> image(cv.score)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("image.tune.rcc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("imgCor")
> ### * imgCor
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: imgCor
> ### Title: Image Maps of Correlation Matrices between two Data Sets
> ### Aliases: imgCor
> ### Keywords: multivariate dplot
> 
> ### ** Examples
> 
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> 
> ## 'combine' type plot (default)
> imgCor(X, Y)
> 
> ## 'separate' type plot
> ## Not run: 
> ##D imgCor(X, Y, type = "separate")
> ##D 
> ##D ## 'separate' type plot without the name of datas
> ##D imgCor(X, Y, X.names = FALSE, Y.names = FALSE, type = "separate")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("imgCor", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ipca")
> ### * ipca
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ipca
> ### Title: Independent Principal Component Analysis
> ### Aliases: ipca
> ### Keywords: algebra
> 
> ### ** Examples
> 
> data(liver.toxicity)
> 
> # implement IPCA on a microarray dataset
> ipca.res <- ipca(liver.toxicity$gene, ncomp = 3, mode="deflation")
> ipca.res

Call:
 ipca(X = liver.toxicity$gene, ncomp = 3, mode = "deflation") 

 IPCA with 3 independent components. 
 You entered data X of dimensions: 64 3116 
 Available components: 
 -------------------- 
 unmixing matrix: see object$unmixing 
 independent principal components: see object$x 
 mxing matrix: see object$mixing 
 kurtosis: see object$kurtosis 
 variable names: see object$names 
 independent loading vectors: see object$loadings 
> 
> # samples representation
> plotIndiv(ipca.res, ind.names = liver.toxicity$treatment[, 4], cex = 0.5, 
+           col = as.numeric(as.factor(liver.toxicity$treatment[, 4])))
Warning in plotIndiv.ipca(ipca.res, ind.names = liver.toxicity$treatment[,  :
  Some of the input arguments do not match the function arguments, see ?plotIndiv
> ## Not run: 
> ##D plot3dIndiv(ipca.res, cex = 0.01,
> ##D             col = as.numeric(as.factor(liver.toxicity$treatment[, 4])))
> ## End(Not run)
> 
> # variables representation
> plotVar(ipca.res, var.label = TRUE, cex = 0.5)
Warning in plotVar.ipca(ipca.res, var.label = TRUE, cex = 0.5) :
  Some of the input arguments do not match the function arguments, see ?plotIndiv
> 
> ## Not run: 
> ##D plot3dVar(ipca.res, rad.in = 0.5, cex = 0.5, 
> ##D           col = as.numeric(as.factor(liver.toxicity$treatment[, 4])))
> ##D           
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ipca", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mat.rank")
> ### * mat.rank
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat.rank
> ### Title: Matrix Rank
> ### Aliases: mat.rank
> ### Keywords: algebra
> 
> ### ** Examples
> 
> ## Hilbert matrix
> hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
> mat <- hilbert(16)
> mat.rank(mat)
$rank
[1] 1

$tol
[1] 6.608177e-15

> 
> ## Hilbert matrix with missing data
> idx.na <- matrix(sample(c(0, 1, 1, 1, 1), 36, replace = TRUE), ncol = 6)
> m.na <- m <- hilbert(9)[, 1:6]
> m.na[idx.na == 0] <- NA
> mat.rank(m)
$rank
[1] 1

$tol
[1] 3.334199e-15

> mat.rank(m.na)
$rank
[1] 1

$tol
[1] 3.459627e-15

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat.rank", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("multilevel")
> ### * multilevel
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: multilevel
> ### Title: Multilevel analysis for repeated measurements (cross-over
> ###   design)
> ### Aliases: multilevel multilevel.splsda multilevel.spls
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> ## First example: one-factor analysis with sPLS-DA
> data(vac18) # vac18 study
> X <- vac18$genes
> Y <- vac18$stimulation
> 
> res <- multilevel(X, cond = Y, ncomp = 3,
+   tab.prob.gene = vac18$tab.prob.gene,
+   sample = vac18$sample, method = "splsda",
+   keepX = c(30, 137, 123))
> 
> ## Not run: 
> ##D # color for plot3dIndiv
> ##D col_stim <- c("darkblue", "purple", "green4","red3")
> ##D cols <- Y
> ##D levels(cols) <- col_stim
> ##D cols <- as.character(cols)
> ##D 
> ##D plot3dIndiv(res, ind.names = Y, col = cols,
> ##D cex = 0.3, axes.box = "both")
> ## End(Not run)
> 
> ## Second example: two-factor analysis with sPLS-DA
> data(data.simu) # simulated data
> 
> time = factor(rep(c(rep('t1', 6), rep('t2', 6)), 4))
> stimu.time = data.frame(cbind(as.character(data.simu$stimu), 
+                         as.character(time)))
> repeat.simu2 = rep(c(1:6), 8)
> 
> res.2level <- multilevel(data.simu$X, cond = stimu.time,
+                          sample = repeat.simu2, ncomp = 2,
+                          keepX = c(200, 200), tab.prob.gene = NULL, 
+                          method = 'splsda')
> 
> # color for plotIndiv
> col.stimu = as.numeric(data.simu$stimu)
> # pch for plots
> pch.time = rep(20, 48)
> pch.time[time == 't2'] = 4
> 
> plotIndiv(res.2level, col = col.stimu, pch = pch.time, ind.names = FALSE)
> legend('bottomright', col = unique(col.stimu), 
+        legend = levels(data.simu$stimu),  pch = 20, cex = 0.8)
> legend('topright', col = 'black', legend = levels(time),  
+        pch = unique(pch.time), cex = 0.8)
> 
> 
> ## Third example: one-factor integrative analysis with sPLS
> ## Not run: 
> ##D data(liver.toxicity)
> ##D repeat.indiv = c(1, 2, 1, 2, 1, 2, 1, 2, 3, 3, 4, 3, 4, 3, 4, 4, 5, 6, 5, 5,
> ##D                  6, 5, 6, 7, 7, 8, 6, 7, 8, 7, 8, 8, 9, 10, 9, 10, 11, 9, 9, 
> ##D                  10, 11, 12, 12, 10, 11, 12, 11, 12, 13, 14, 13, 14, 13, 14, 
> ##D                  13, 14, 15, 16, 15, 16, 15, 16, 15, 16)
> ##D 
> ##D result.rat <- multilevel(X = liver.toxicity$gene, Y=liver.toxicity$clinic, 
> ##D                          cond = liver.toxicity$treatment$Dose.Group, 
> ##D                          sample = repeat.indiv, ncomp = 2, keepX = c(50, 50), 
> ##D                          keepY = c(5, 5), method = 'spls') 
> ##D 
> ##D # variable plots
> ##D plotVar(result.rat, comp = 1:2, X.label = TRUE, Y.label = TRUE, 
> ##D         cex = c(0.5, 0.9)) 
> ##D 
> ##D CIM <- cim(result.rat, comp = 1:2, xlab = "genes", ylab = "clinic var", 
> ##D            margins = c(5, 6), zoom = FALSE)
> ##D 
> ##D 
> ##D network(result.rat, comp = 1:2, threshold = 0.8, 
> ##D         Y.names = NULL, keep.var = TRUE,
> ##D         color.node = c( "lightcyan","mistyrose"),
> ##D         shape.node = c("circle", "rectangle"),
> ##D         color.edge = c("red", "green"),
> ##D         lty.edge = c("solid", "solid"), lwd.edge = c(1, 1), 
> ##D         show.edge.labels = FALSE, interactive = FALSE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("multilevel", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("network")
> ### * network
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: network
> ### Title: Relevance Network for (r)CCA and (s)PLS regression
> ### Aliases: network.default network.rcc network.pls network.spls network
> ### Keywords: multivariate graphs dplot hplot iplot
> 
> ### ** Examples
> 
> 
> ## network representation for objects of class 'rcc'
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
> 
> ## Not run: 
> ##D    # may not work on the Linux version, use Windows instead
> ##D network(nutri.res, comp = 1:3, threshold = 0.6)
> ## End(Not run)
> 
> ## Changing the attributes of the network
> ## Not run: 
> ##D network(nutri.res, comp = 1:3, threshold = 0.45,
> ##D         color.node = c("mistyrose", "lightcyan"),,
> ##D         shape.node = c("circle", "rectangle"), 
> ##D         color.edge = jet.colors(8),
> ##D         lty.edge = c("solid", "solid"), lwd.edge = c(2, 2), 
> ##D         show.edge.labels = FALSE)
> ## End(Not run)
> 
> ## interactive 'threshold' 
> ## Not run: 
> ##D network(nutri.res, comp = 1:3, threshold = 0.55, interactive = TRUE)
> ##D ## select the 'threshold' and "see" the new network
> ## End(Not run)
> 
> ## network representation for objects of class 'spls'
> data(liver.toxicity)
> X <- liver.toxicity$gene
> Y <- liver.toxicity$clinic
> toxicity.spls <- spls(X, Y, ncomp = 3, keepX = c(50, 50, 50), 
+                       keepY = c(10, 10, 10))
> ## Not run: 
> ##D network(toxicity.spls, comp = 1:3, threshold = 0.8, 
> ##D         X.names = NULL, Y.names = NULL, keep.var = TRUE,
> ##D         color.node = c("mistyrose", "lightcyan"),
> ##D         shape.node = c("rectangle", "circle"),
> ##D         color.edge = c("red", "blue"),
> ##D         lty.edge = c("solid", "solid"), lwd.edge = c(1, 1), 
> ##D         show.edge.labels = FALSE, interactive = FALSE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("network", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("nipals")
> ### * nipals
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nipals
> ### Title: Non-linear Iterative Partial Least Squares (NIPALS) algorithm
> ### Aliases: nipals
> ### Keywords: algebra multivariate
> 
> ### ** Examples
> 
> ## Hilbert matrix
> hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
> X.na <- X <- hilbert(9)[, 1:6]
> 
> ## Hilbert matrix with missing data
> idx.na <- matrix(sample(c(0, 1, 1, 1, 1), 36, replace = TRUE), ncol = 6)
> X.na[idx.na == 0] <- NA
> X.rec <- nipals(X.na, reconst = TRUE)$rec
> round(X, 2)
      [,1] [,2] [,3] [,4] [,5] [,6]
 [1,] 1.00 0.50 0.33 0.25 0.20 0.17
 [2,] 0.50 0.33 0.25 0.20 0.17 0.14
 [3,] 0.33 0.25 0.20 0.17 0.14 0.12
 [4,] 0.25 0.20 0.17 0.14 0.12 0.11
 [5,] 0.20 0.17 0.14 0.12 0.11 0.10
 [6,] 0.17 0.14 0.12 0.11 0.10 0.09
 [7,] 0.14 0.12 0.11 0.10 0.09 0.08
 [8,] 0.12 0.11 0.10 0.09 0.08 0.08
 [9,] 0.11 0.10 0.09 0.08 0.08 0.07
> round(X.rec, 2)
      [,1] [,2] [,3] [,4] [,5] [,6]
 [1,] 0.93 0.62 0.40 0.32 0.27 0.33
 [2,] 0.51 0.34 0.22 0.18 0.15 0.18
 [3,] 0.37 0.25 0.16 0.13 0.11 0.13
 [4,] 0.30 0.20 0.13 0.10 0.09 0.10
 [5,] 0.25 0.17 0.11 0.09 0.07 0.09
 [6,] 0.20 0.14 0.09 0.07 0.06 0.07
 [7,] 0.18 0.12 0.08 0.06 0.05 0.06
 [8,] 0.17 0.11 0.07 0.06 0.05 0.06
 [9,] 0.14 0.10 0.06 0.05 0.04 0.05
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nipals", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pca")
> ### * pca
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pca
> ### Title: Principal Components Analysis
> ### Aliases: pca
> ### Keywords: algebra
> 
> ### ** Examples
> 
> data(multidrug)
> 
> ## this data set contains missing values, therefore 
> ## the 'prcomp' function cannot be applied
> pca.res <- pca(multidrug$ABC.trans, ncomp = 4, scale = TRUE)
> plot(pca.res)
> print(pca.res)
Eigenvalues for the first  4 principal components: 
     PC1      PC2      PC3      PC4 
6.083071 4.891838 3.364484 3.002343 

> biplot(pca.res, xlabs = multidrug$cell.line$Class, cex = 0.7)
> 
> # samples representation
> plotIndiv(pca.res, ind.names = multidrug$cell.line$Class, cex = 0.5, 
+           col = as.numeric(as.factor(multidrug$cell.line$Class)))
Warning in plotIndiv.pca(pca.res, ind.names = multidrug$cell.line$Class,  :
  Some of the input arguments do not match the function arguments, see ?plotIndiv
> ## Not run: 
> ##D plot3dIndiv(pca.res, cex = 0.2,
> ##D             col = as.numeric(as.factor(multidrug$cell.line$Class)))
> ## End(Not run)
> # variables representation
> plotVar(pca.res, var.label = TRUE)
> ## Not run: 
> ##D plot3dVar(pca.res, rad.in = 0.5, var.label = TRUE, cex = 0.5)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pca", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("perf")
> ### * perf
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: perf
> ### Title: Compute evaluation criteria for PLS, sPLS, PLS-DA and sPLS-DA
> ### Aliases: perf perf.pls perf.spls perf.plsda perf.splsda
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> ## validation for objects of class 'pls' (regression)
> # ----------------------------------------
> ## Not run: 
> ##D data(liver.toxicity)
> ##D X <- liver.toxicity$gene
> ##D Y <- liver.toxicity$clinic
> ##D 
> ##D 
> ##D # try tune the number of component to choose
> ##D # ---------------------
> ##D # first learn the full model
> ##D liver.pls <- pls(X, Y, ncomp = 10)
> ##D 
> ##D # with 5-fold cross validation: we use the same parameters as in model above
> ##D # but we perform cross validation to compute the MSEP, Q2 and R2 criteria
> ##D # ---------------------------
> ##D liver.val <- perf(liver.pls, validation = "Mfold", folds = 5)
> ##D 
> ##D # Q2 total should decrease until it reaches a threshold
> ##D liver.val$Q2.total
> ##D 
> ##D # ncomp = 3 is enough
> ##D plot(liver.val$Q2.total, type = 'l', col = 'red', ylim = c(-0.1, 0.5), 
> ##D 	xlab = 'PLS components', ylab = 'Q2 total')
> ##D abline(h = 0.0975, col = 'darkgreen')
> ##D legend('topright', col = c('red', 'darkgreen'), legend = c('Q2 total', 'threshold 0.0975')
> ##D 	, lty = 1)
> ##D title('Liver toxicity PLS 5-fold, Q2 values')
> ##D 
> ##D #have a look at the other criteria
> ##D # ----------------------
> ##D # R2
> ##D liver.val$R2
> ##D matplot(t(liver.val$R2), type = 'l', xlab = 'PLS components', ylab = 'R2 for each variable')
> ##D title('Liver toxicity PLS 5-fold, R2 values')
> ##D 
> ##D # MSEP
> ##D liver.val$MSEP
> ##D matplot(t(liver.val$MSEP), type = 'l', xlab = 'PLS components', ylab = 'MSEP for each variable')
> ##D title('Liver toxicity PLS 5-fold, MSEP values')
> ##D 
> ##D 
> ##D ## validation for objects of class 'spls' (regression)
> ##D # ----------------------------------------
> ##D ncomp = 7
> ##D # first, learn the model on the whole data set
> ##D model.spls = spls(X, Y, ncomp = ncomp, mode = 'regression',
> ##D 	 keepX = c(rep(5, ncomp)), keepY = c(rep(2,ncomp)))
> ##D 
> ##D 
> ##D # with leave-one-out cross validation
> ##D set.seed(45)
> ##D model.spls.loo.val <- perf(model.spls, validation = "loo")
> ##D 
> ##D #Q2 total
> ##D model.spls.loo.val$Q2.total
> ##D 
> ##D # R2:we can see how the performance degrades when ncomp increases
> ##D # results are similar to 5-fold
> ##D model.spls.loo.val$R2
> ##D 
> ##D 
> ##D ## validation for objects of class 'splsda' (classification)
> ##D # ----------------------------------------
> ##D data(srbct)
> ##D X <- srbct$gene
> ##D Y <- srbct$class  
> ##D 
> ##D ncomp = 5
> ##D 
> ##D srbct.splsda <- splsda(X, Y, ncomp = ncomp, keepX = rep(10, ncomp))  
> ##D 
> ##D # with Mfold
> ##D # ---------
> ##D set.seed(45)
> ##D error <- perf(srbct.splsda, validation = "Mfold", folds = 8, 
> ##D                method.predict = "all")
> ##D 
> ##D plot(error, type = "l")
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("perf", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pheatmap.multilevel")
> ### * pheatmap.multilevel
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pheatmap.multilevel
> ### Title: Clustered heatmap
> ### Aliases: pheatmap.multilevel pheatmap.multilevel.splsda1fact
> ###   pheatmap.multilevel.splsda2fact
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> ## First example: one-factor analysis with sPLS-DA
> data(data.simu) # simulated data
> res.1level <- multilevel(data.simu$X, cond = data.simu$stimu, sample=data.simu$sample, ncomp=3,
+                          keepX=c(200,200,200),tab.prob.gene=NULL, method = 'splsda')
> 
> #color for heatmap
> col.stimu = as.numeric(data.simu$stimu)
> col.stimu <- c("darkblue","purple","green4","red3")
> col.sample <- c("lightgreen", "red","lightblue","darkorange",
+   "purple","maroon","blue","chocolate","turquoise","tomato1",
+   "pink2","aquamarine")
> 
> pheatmap.multilevel(res.1level, col_sample=col.sample, col_stimulation=col.stimu, 
+               label_annotation=NULL,border=FALSE,clustering_method="ward",
+               show_colnames = FALSE,show_rownames = TRUE,fontsize_row=2)
The "ward" method has been renamed to "ward.D"; note new "ward.D2"
The "ward" method has been renamed to "ward.D"; note new "ward.D2"
> 
> 
> ## Second example: two-factor analysis with sPLS-DA
> ## Not run: 
> ##D data(data.simu) # simulated data
> ##D 
> ##D time = factor(rep(c(rep('t1', 6), rep('t2', 6)), 4))
> ##D stimu.time = data.frame(cbind(as.character(data.simu$stimu), as.character(time)))
> ##D repeat.simu2 = rep(c(1:6), 8)
> ##D 
> ##D res.2level = multilevel(data.simu$X, cond = stimu.time,sample=repeat.simu2, 
> ##D                         ncomp=2,keepX=c(200, 200),tab.prob.gene=NULL, method = 'splsda')
> ##D 
> ##D # color for plotIndiv
> ##D col.stimu = as.numeric(data.simu$stimu)
> ##D col.sample = c("lightgreen", "red","lightblue","darkorange","purple","maroon") # 6 samples
> ##D col.time= c("pink","lightblue1") # two time points
> ##D col.stimu = c('green', 'black', 'red', 'blue') # 4 stimulations
> ##D label.stimu = unique(data.simu$stimu)
> ##D label.time = unique(time)
> ##D 
> ##D pheatmap.multilevel(res.2level, 
> ##D               col_sample=col.sample, 
> ##D               col_stimulation=col.stimu, 
> ##D               col_time=col.time,
> ##D               label_color_stimulation=label.stimu,
> ##D               label_color_time=label.time, 
> ##D               label_annotation=NULL,border=FALSE,
> ##D               clustering_method="ward",
> ##D               show_colnames = FALSE,
> ##D               show_rownames = TRUE,
> ##D               fontsize_row=2)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pheatmap.multilevel", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plot.perf")
> ### * plot.perf
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot.perf
> ### Title: Plot for model performance
> ### Aliases: plot.perf
> ### Keywords: regression multivariate hplot
> 
> ### ** Examples
> 
> require(lattice)
> 
> ## validation for objects of class 'pls' or 'spls'
> ## Not run: 
> ##D data(liver.toxicity)
> ##D X <- liver.toxicity$gene
> ##D Y <- liver.toxicity$clinic
> ##D 
> ##D liver.pls <- pls(X, Y, ncomp = 3)
> ##D liver.perf <- perf(liver.pls, validation = "Mfold")
> ##D 				   
> ##D plot(liver.perf, criterion = "R2", type = "l", layout = c(2, 2))
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot.perf", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plot.rcc")
> ### * plot.rcc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot.rcc
> ### Title: Canonical Correlations Plot
> ### Aliases: plot.rcc
> ### Keywords: multivariate hplot
> 
> ### ** Examples
> 
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> nutri.res <- rcc(X, Y, lambda1 = 0.064, lambda2 = 0.008)
> 
> ## 'pointplot' type scree 
> plot(nutri.res) #(default)
> 
> plot(nutri.res, pch = 19, cex = 1.2, 
+      col = c(rep("red", 3), rep("darkblue", 18)))
> 
> ## 'barplot' type scree
> plot(nutri.res, scree.type = "barplot")
> 
> plot(nutri.res, scree.type = "barplot", density = 20, col = "black")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot.rcc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plot3dIndiv")
> ### * plot3dIndiv
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot3dIndiv
> ### Title: Plot of Individuals (Experimental Units) in three dimensions
> ### Aliases: plot3dIndiv plot3dIndiv.rcc plot3dIndiv.pls plot3dIndiv.spls
> ###   plot3dIndiv.plsda plot3dIndiv.splsda plot3dIndiv.pca plot3dIndiv.spca
> ### Keywords: multivariate hplot dplot
> 
> ### ** Examples
> 
> require(rgl)
Loading required package: rgl
Warning: package ‘rgl’ was built under R version 3.1.1
> 
> ## Not run: 
> ##D ## plot3d of individuals for objects of class 'rcc' 
> ##D data(nutrimouse)
> ##D X <- nutrimouse$lipid
> ##D Y <- nutrimouse$gene
> ##D nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
> ##D 
> ##D col = nutrimouse$diet
> ##D font = c(rep(1, 20), rep(3, 20))
> ##D plot3dIndiv(nutri.res, ind.names = nutrimouse$diet, 
> ##D                 axes.box = "box", font = font, col = col)
> ##D 				
> ##D pch = c(rep("s", 20), rep("t", 20))
> ##D plot3dIndiv(nutri.res, ind.names = FALSE, axes.box = "both", 
> ##D                 col = col, cex = 1.5, pch = pch)
> ##D 
> ##D ## plot3d of individuals for objects of class 'pls' or 'spls'	   
> ##D data(liver.toxicity)
> ##D X <- liver.toxicity$gene
> ##D Y <- liver.toxicity$clinic
> ##D toxicity.spls <- spls(X, Y, ncomp = 3, keepX = c(50, 50, 50), 
> ##D                       keepY = c(10, 10, 10))
> ##D 		  	
> ##D Time.Group = liver.toxicity$treatment[, "Time.Group"]				  
> ##D col <- rep(c("blue", "red", "darkgreen", "darkviolet"), rep(16, 4))
> ##D plot3dIndiv(toxicity.spls, ind.names = Time.Group, 
> ##D                  col = col, cex = 0.8)		  
> ##D 		  				  
> ##D col <- rainbow(48)[Time.Group]
> ##D plot3dIndiv(toxicity.spls, ind.names = FALSE, 
> ##D                  col = col, cex = 0.3, axes.box = "both")	
> ##D 
> ##D ## plot3d of individuals for objects of class 'pca'	   
> ##D data(multidrug)
> ##D pca.res <- pca(multidrug$ABC.trans, ncomp = 4, scale = TRUE)
> ##D 
> ##D palette(rainbow(9))
> ##D col = as.numeric(as.factor(multidrug$cell.line$Class))
> ##D plot3dIndiv(pca.res, cex = 0.25, col = col)
> ##D palette("default")				 
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot3dIndiv", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgl’

> nameEx("plot3dVar")
> ### * plot3dVar
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot3dVar
> ### Title: Plot of Variables in three dimensions
> ### Aliases: plot3dVar plot3dVar.rcc plot3dVar.pls plot3dVar.spls
> ###   plot3dVar.plsda plot3dVar.splsda plot3dVar.pca plot3dVar.spca
> ### Keywords: multivariate hplot dplot
> 
> ### ** Examples
> 
> require(rgl)
Loading required package: rgl
Warning: package ‘rgl’ was built under R version 3.1.1
> 
> ## Not run: 
> ##D ## 3D variable representation for objects of class 'rcc'
> ##D data(nutrimouse)
> ##D X <- nutrimouse$lipid
> ##D Y <- nutrimouse$gene
> ##D nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
> ##D 
> ##D \dontrun{
> ##D # default
> ##D plot3dVar(nutri.res)
> ##D 
> ##D # cutoff active, labeling the variables
> ##D plot3dVar(nutri.res, cutoff = 0.7, X.label = TRUE, cex = c(0.8, 0.8))
> ##D }
> ##D ## 3D variable representation for objects of class 'pls' or 'spls'
> ##D data(liver.toxicity)
> ##D X <- liver.toxicity$gene
> ##D Y <- liver.toxicity$clinic
> ##D toxi.spls.1 <- spls(X, Y, ncomp = 3, keepX = c(50, 50, 50), 
> ##D                     keepY = c(10, 10, 10))
> ##D \dontrun{        
> ##D plot3dVar(toxi.spls.1, rad.in = 0.5, keep.var = TRUE, cex = c(1, 0.8), 
> ##D           main = "Variables 3D representation") 
> ##D }
> ##D toxi.spls.2 <- spls(X, Y, ncomp = 3, keepX = c(10, 10, 10), 
> ##D                     keepY = c(10, 10, 10))
> ##D 					  
> ##D plot3dVar(toxi.spls.2, rad.in = 0.5, Y.label = TRUE, 
> ##D           main = "Variables 3D representation", 
> ##D           label.axes.box = "axes")
> ##D 	
> ##D ## 3D variable representation for objects of class 'pca'	   
> ##D data(multidrug)
> ##D pca.res <- pca(multidrug$ABC.trans, ncomp = 4, scale = TRUE)
> ##D 
> ##D plot3dVar(pca.res)
> ##D 
> ##D ## variable representation for objects of class 'splsda'
> ##D data(liver.toxicity)
> ##D X <- liver.toxicity$gene
> ##D Y <- as.factor(liver.toxicity$treatment[, 4])
> ##D 
> ##D ncomp <- 3
> ##D keepX <- rep(20, ncomp)
> ##D 
> ##D splsda.liver <- splsda(X, Y, ncomp = ncomp, keepX = keepX)
> ##D \dontrun{
> ##D plot3dVar(splsda.liver, var.label = FALSE, Y.label = TRUE, keep.var = TRUE)
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot3dVar", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgl’

> nameEx("plotIndiv")
> ### * plotIndiv
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotIndiv
> ### Title: Plot of Individuals (Experimental Units)
> ### Aliases: plotIndiv plotIndiv.rcc plotIndiv.pls plotIndiv.spls
> ###   plotIndiv.plsda plotIndiv.splsda plotIndiv.pca plotIndiv.spca
> ###   plotIndiv.rgcca plotIndiv.sgcca
> ### Keywords: multivariate hplot dplot
> 
> ### ** Examples
> 
> ## plot of individuals for objects of class 'rcc' 
> # ----------------------------------------------------
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
> 
> plotIndiv(nutri.res) #(default) 
> 
> col <- rep(c("blue", "red"), c(20, 20))
> plotIndiv(nutri.res, ind.names = nutrimouse$diet, col = col)
> legend(-2.2, -1.1, c("WT", "PPAR"), pch = c(16, 16), 
+        col = c("blue", "red"), text.col = c("blue", "red"),
+        cex = 1, pt.cex = c(1.2, 1.2))
> 
> ## plot of individuals for objects of class 'pls' or 'spls'	
> # ----------------------------------------------------   
> data(liver.toxicity)
> X <- liver.toxicity$gene
> Y <- liver.toxicity$clinic
> toxicity.spls <- spls(X, Y, ncomp = 3, keepX = c(50, 50, 50), 
+                       keepY = c(10, 10, 10))
> 		  
> col <- rep(c("blue", "red", "darkgreen", "darkviolet"), rep(16, 4))
> cex <- rep(c(1, 1.2, 1, 1.4), c(16, 16, 16, 16))
> pch <- rep(c(15, 16, 17, 18), c(16, 16, 16, 16))
> plotIndiv(toxicity.spls, comp = 1:2, ind.names = FALSE,
+           rep.space = "X-variate", col = col, cex = cex, pch = pch)
> legend("topright", c("50 mg/kg", "150 mg/kg", "1500 mg/kg", "2000 mg/kg"), 
+        col = c("blue", "red", "darkgreen", "darkviolet"), 
+        pch = c(15, 16, 17, 18), pt.cex = c(1, 1.2, 1, 1.4), 
+        title = "Treatment")
>        
> ## variable representation for objects of class 'sgcca' (or 'rgcca')
> # ----------------------------------------------------
> data(nutrimouse)
> 
> # need to unmap the Y factor diet
> Y = unmap(nutrimouse$diet)
> data = list(nutrimouse$gene, nutrimouse$lipid,Y)
> # with this design, gene expression and lipids are connected to the diet factor
> # and gene expression and lipids are also connected
> design = matrix(c(0,1,1,
+                   1,0,1,
+                   1,1,0), ncol = 3, nrow = 3, byrow = TRUE)
> 
> #note: the penalty parameters will need to be tuned
> wrap.result.sgcca = wrapper.sgcca(data = data, design = design, penalty = c(.3,.5, 1), 
+                                   ncomp = c(2, 2, 1),
+                                   scheme = "centroid", verbose = FALSE)
> 
> 
> # on the first data set
> plotIndiv(wrap.result.sgcca, rep.space = 1, ind.names = TRUE, 
+           col = as.numeric(nutrimouse$diet), cex = .6)
> # on the second data set
> plotIndiv(wrap.result.sgcca, rep.space = 2, ind.names = TRUE, 
+           col = as.numeric(nutrimouse$diet), cex = .6)
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotIndiv", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plotVar")
> ### * plotVar
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotVar
> ### Title: Plot of Variables
> ### Aliases: plotVar plotVar.rcc plotVar.pls plotVar.spls plotVar.plsda
> ###   plotVar.splsda plotVar.pca plotVar.spca plotVar.sgcca plotVar.rgcca
> ### Keywords: multivariate hplot dplot
> 
> ### ** Examples
> 
> ## variable representation for objects of class 'rcc'
> # ----------------------------------------------------
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
> 
> plotVar(nutri.res) #(default)
> 
> plotVar(nutri.res, comp = 1:2, cutoff = 0.5, 
+         X.label = TRUE, Y.label = TRUE)
Warning in plotVar.rcc(nutri.res, comp = 1:2, cutoff = 0.5, X.label = TRUE,  :
  Some of the input arguments do not match the function arguments, see ?plotIndiv
> 
> ## variable representation for objects of class 'pls' or 'spls'
> # ----------------------------------------------------
> data(liver.toxicity)
> X <- liver.toxicity$gene
> Y <- liver.toxicity$clinic
> toxicity.spls <- spls(X, Y, ncomp = 3, keepX = c(50, 50, 50), 
+                       keepY = c(10, 10, 10))
> 	
> plotVar(toxicity.spls, keep.var = TRUE, Y.label = TRUE, cex = c(1,0.8))	
Warning in plotVar.spls(toxicity.spls, keep.var = TRUE, Y.label = TRUE,  :
  Some of the input arguments do not match the function arguments, see ?plotIndiv
> 
> ## variable representation for objects of class 'splsda'
> # ----------------------------------------------------
> ## Not run: 
> ##D data(liver.toxicity)
> ##D X <- liver.toxicity$gene
> ##D Y <- as.factor(liver.toxicity$treatment[, 4])
> ##D 
> ##D ncomp <- 2
> ##D keepX <- rep(20, ncomp)
> ##D 
> ##D splsda.liver <- splsda(X, Y, ncomp = ncomp, keepX = keepX)
> ##D plotVar(splsda.liver, var.label = FALSE)
> ## End(Not run)
> 
> ## variable representation for objects of class 'sgcca' (or 'rgcca')
> # ----------------------------------------------------
> data(nutrimouse)
> 
> # need to unmap the Y factor diet
> Y = unmap(nutrimouse$diet)
> data = list(nutrimouse$gene, nutrimouse$lipid,Y)
> # with this design, gene expression and lipids are connected to the diet factor
> # and gene expression and lipids are also connected
> design = matrix(c(0,1,1,
+                   1,0,1,
+                   1,1,0), ncol = 3, nrow = 3, byrow = TRUE)
> 
> #note: the penalty parameters will need to be tuned
> wrap.result.sgcca = wrapper.sgcca(data = data, design = design, penalty = c(.3,.5, 1), 
+                                   ncomp = c(2, 2, 1),
+                                   scheme = "centroid", verbose = FALSE)
> par(mfrow=c(2,2))
> plotVar(wrap.result.sgcca, comp = c(1,2), block = c(1,2), ncomp.select = c(1,2))
PlotVar only display variables selected on components 1 2 
> plotVar(wrap.result.sgcca, comp = c(1,2), block = c(1,2), ncomp.select = c(1,2), labels = TRUE)
PlotVar only display variables selected on components 1 2 
> plotVar(wrap.result.sgcca, comp = c(1,2), block = c(1,2), ncomp.select = 1, labels = TRUE)
PlotVar only display variables selected on components 1 
> plotVar(wrap.result.sgcca, comp = c(1,2), block = 1, ncomp.select = 1, labels = TRUE)
Warning in plotVar.sgcca(wrap.result.sgcca, comp = c(1, 2), block = 1, ncomp.select = 1,  :
  Will only take into account the first 1 arguments (pch, cex, font or cex) for the plot
PlotVar only display variables selected on components 1 
> par(mfrow=c(1,1))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotVar", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("pls")
> ### * pls
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pls
> ### Title: Partial Least Squares (PLS) Regression
> ### Aliases: pls
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> data(linnerud)
> X <- linnerud$exercise
> Y <- linnerud$physiological
> linn.pls <- pls(X, Y, mode = "classic")
> 
> data(liver.toxicity)
> X <- liver.toxicity$gene
> Y <- liver.toxicity$clinic
> 
> toxicity.pls <- pls(X, Y, ncomp = 3)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pls", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plsda")
> ### * plsda
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plsda
> ### Title: Partial Least Squares Discriminate Analysis (PLS-DA).
> ### Aliases: plsda
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> ## First example
> data(breast.tumors)
> X <- breast.tumors$gene.exp
> Y <- breast.tumors$sample$treatment
> 
> plsda.breast <- plsda(X, Y, ncomp = 2)
> palette(c("red", "blue"))
> col.breast <- as.numeric(as.factor(Y))
> plotIndiv(plsda.breast, ind.names = TRUE, col = col.breast)
> legend('bottomleft', c("After", "Before"), pch = c(16, 16), 
+        col = unique(col.breast), cex = 1, pt.cex = c(1.2, 1.2), 
+        title = "Treatment")
> palette("default")
> 
> ## Not run: 
> ##D ## Second example
> ##D data(liver.toxicity)
> ##D X <- liver.toxicity$gene
> ##D Y <- liver.toxicity$treatment[, 4]
> ##D 
> ##D plsda.liver <- plsda(X, Y, ncomp = 2)
> ##D col.rat <- as.numeric(as.factor(Y))
> ##D plotIndiv(plsda.liver, col = col.rat, ind.names = Y)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plsda", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("predict")
> ### * predict
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: predict
> ### Title: Predict Method for PLS, sPLS, PLS-DA or sPLS-DA
> ### Aliases: predict.splsda predict.plsda predict.pls predict.spls
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> data(linnerud)
> X <- linnerud$exercise
> Y <- linnerud$physiological
> linn.pls <- pls(X, Y, ncomp = 2, mode = "classic")
> 
> indiv1 <- c(200, 40, 60)
> indiv2 <- c(190, 45, 45)
> newdata <- rbind(indiv1, indiv2)
> colnames(newdata) <- colnames(X)
> newdata
       Weight Waist Pulse
indiv1    200    40    60
indiv2    190    45    45
> 
> pred <- predict(linn.pls, newdata)
> 
> plotIndiv(linn.pls, comp = 1:2, rep.space = "X-variate")
> points(pred$variates[, 1], pred$variates[, 2], pch = 19, cex = 1.2)
> text(pred$variates[, 1], pred$variates[, 2], 
+      c("new ind.1", "new ind.2"), pos = 3)
> 	 
> ## First example with plsda
> data(liver.toxicity)
> X <- liver.toxicity$gene
> Y <- as.factor(liver.toxicity$treatment[, 4])
> 
> ## if training is perfomed on 4/5th of the original data
> samp <- sample(1:5, nrow(X), replace = TRUE)  
> test <- which(samp == 1)   # testing on the first fold
> train <- setdiff(1:nrow(X), test)
> 
> plsda.train <- plsda(X[train, ], Y[train], ncomp = 2)
> test.predict <- predict(plsda.train, X[test, ], method = "max.dist")
> Prediction <- levels(Y)[test.predict$class$max.dist[, 2]]
> cbind(Y = as.character(Y[test]), Prediction)
      Y    Prediction
 [1,] "6"  "6"       
 [2,] "18" "48"      
 [3,] "48" "48"      
 [4,] "18" "48"      
 [5,] "6"  "6"       
 [6,] "24" "24"      
 [7,] "48" "48"      
 [8,] "48" "18"      
 [9,] "48" "18"      
> 
> ## Not run: 
> ##D ## Second example with splsda
> ##D splsda.train <- splsda(X[train, ], Y[train], ncomp = 2, keepX = c(30, 30))
> ##D test.predict <- predict(splsda.train, X[test, ], method = "max.dist")
> ##D Prediction <- levels(Y)[test.predict$class$max.dist[, 2]]
> ##D cbind(Y = as.character(Y[test]), Prediction)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("predict", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("print.methods")
> ### * print.methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: print
> ### Title: Print Methods for CCA, (s)PLS, PCA and Summary objects
> ### Aliases: print print.rcc print.pls print.spls print.summary print.pca
> ###   print.spca print.rgcca print.sgcca
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> ## print for objects of class 'rcc'
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
> print(nutri.res)

Call:
 rcc(X = X, Y = Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008) 

 rCCA with 3 components and regularization parameters 0.064 and 0.008 for the X and Y data. 
 You entered data X of dimensions : 40 21 
 You entered data Y of dimensions : 40 120 

 Available components: 
 -------------------- 
 canonical correlations: see object$cor 
 loading vectors: see object$loadings 
 variates: see object$variates 
 variable names: see object$names 
> 
> ## print for objects of class 'summary'
> more <- summary(nutri.res, cutoff = 0.65)
> print(more)
 Number of canonical variates considered: 3 

 Canonical correlations: 
 ----------------------
   1th       2th       3th    
0.9644    0.9322    0.8943    


 Canonical Communalities Analysis:
 --------------------------------
 X-Variables vs their own Canonical Variates: see object$Cm.X$own 

 X-Variables vs the opposite Canonical Variates: see object$Cm.X$opp 

 Y-Variables vs their own Canonical Variates: see object$Cm.Y$own 

 Y-Variables vs the opposite Canonical Variates: see object$Cm.Y$opp 


 Redundancy Analysis:
 -------------------

 X-Variables vs their own Variates: see object$Rd.X$own 

 X-Variables vs the opposite Variates: see object$Rd.X$opp 

 Y-Variables vs their own Variates: see object$Rd.Y$opp 

 Y-Variables vs the opposite Variates: see object$Rd.Y$opp 
> 
> ## print for objects of class 'pls'
> data(linnerud)
> X <- linnerud$exercise
> Y <- linnerud$physiological
> linn.pls <- pls(X, Y)
> print(linn.pls)

Call:
 pls(X = X, Y = Y) 

 PLS with a 'regression' mode with 2 PLS components. 
 You entered data X of dimensions: 20 3 
 You entered data Y of dimensions: 20 3 

 No variable selection. 

 Available components: 
 -------------------- 
 loading vectors: see object$loadings 
 variates: see object$variates 
 variable names: see object$names 
> 
> ## print for objects of class 'spls'
> data(liver.toxicity)
> X <- liver.toxicity$gene
> Y <- liver.toxicity$clinic
> toxicity.spls <- spls(X, Y, ncomp = 3, keepX = c(50, 50, 50), 
+                       keepY = c(10, 10, 10))
> print(toxicity.spls)

Call:
 spls(X = X, Y = Y, ncomp = 3, keepX = c(50, 50, 50), keepY = c(10, 10, 10)) 

 sPLS with a 'regression' mode with 3 sPLS components. 
 You entered data X of dimensions: 64 3116 
 You entered data Y of dimensions: 64 10 

 Selection of [50] [50] [50] variables on each of the sPLS components on the X data set. 
 Selection of [10] [10] [10] variables on each of the sPLS components on the Y data set. 

 Available components: 
 -------------------- 
 loading vectors: see object$loadings 
 variates: see object$variates 
 variable names: see object$names 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("print.methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rcc")
> ### * rcc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rcc
> ### Title: Regularized Canonical Correlation Analysis
> ### Aliases: rcc rcc.default
> ### Keywords: multivariate
> 
> ### ** Examples
> 
> ## Classic CCA
> data(linnerud)
> X <- linnerud$exercise
> Y <- linnerud$physiological
> linn.res <- rcc(X, Y)
> 
> ## Regularized CCA
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rcc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("s.match")
> ### * s.match
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: s.match
> ### Title: Plot of Paired Coordinates
> ### Aliases: s.match
> ### Keywords: multivariate hplot
> 
> ### ** Examples
> 
> 
> ## relevant only for canonical mode
> data(liver.toxicity)
> X <- liver.toxicity$gene
> Y <- liver.toxicity$clinic
> toxicity.spls <- spls(X, Y, mode = "canonical", ncomp = 3, 
+                       keepX = c(50, 50, 50), keepY = c(10, 10, 10))
> 
> color.toxicity <- as.numeric(liver.toxicity$treatment[, 2])
> label.toxicity <- liver.toxicity$treatment[, 1]
> s.match(toxicity.spls$variates$X[, c(1, 2)], 
+         toxicity.spls$variates$Y[, c(1, 2)], 
+         clabel = 0.5, label = label.toxicity, col = color.toxicity)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("s.match", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("select.var")
> ### * select.var
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: select.var
> ### Title: Output of selected variables
> ### Aliases: select.var select.var.spls select.var.splsda select.var.spca
> ###   select.var.sipca select.var.sgcca
> 
> ### ** Examples
> 
> data(liver.toxicity)
> X = liver.toxicity$gene
> Y = liver.toxicity$clinic
> 
> # example with sPCA
> # ------------------
> liver.spca <- spca(X, ncomp = 1, keepX = 10)
> select.var(liver.spca, comp = 1)$name
 [1] "A_43_P16829"  "A_42_P680505" "A_43_P20475"  "A_43_P11409"  "A_43_P21269" 
 [6] "A_42_P814129" "A_43_P20891"  "A_43_P20281"  "A_43_P14037"  "A_42_P751969"
> select.var(liver.spca, comp = 1)$value
                value.var
A_43_P16829  -0.528724414
A_42_P680505 -0.428398868
A_43_P20475  -0.411854421
A_43_P11409  -0.336503346
A_43_P21269  -0.331792306
A_42_P814129 -0.245533902
A_43_P20891  -0.220040298
A_43_P20281  -0.175262121
A_43_P14037  -0.067349863
A_42_P751969 -0.004770662
> 
> #example with sIPCA
> # -----------------
> ## Not run: 
> ##D liver.sipca <- sipca(X, ncomp = 3, keepX = rep(10, 3))
> ##D select.var(liver.sipca, comp = 1)
> ## End(Not run)
> 
> # example with sPLS
> # -----------------
> ## Not run: 
> ##D liver.spls = spls(X, Y, ncomp = 2, keepX = c(20, 40),keepY = c(5, 5))
> ##D select.var(liver.spls, comp = 2)
> ##D 
> ##D # example with sPLS-DA
> ##D data(srbct)   # an example with no gene name in the data
> ##D X = srbct$gene
> ##D Y = srbct$class
> ##D 
> ##D srbct.splsda = splsda(X, Y, ncomp = 2, keepX = c(5, 10))
> ##D select = select.var(srbct.splsda, comp = 2)
> ##D select
> ##D # this is a very specific case where a data set has no rownames. 
> ##D srbct$gene.name[substr(select$select, 2,5),]  
> ## End(Not run)
> 
> # example with sGCCA
> # -----------------
> ## Not run: 
> ##D data(nutrimouse)
> ##D 
> ##D # ! need to unmap the Y factor
> ##D Y = unmap(nutrimouse$diet)
> ##D data = list(nutrimouse$gene, nutrimouse$lipid,Y)
> ##D # in this design, gene expression and lipids are connected to the diet factor
> ##D # and gene expression and lipids are also connected
> ##D design = matrix(c(0,1,1,
> ##D                   1,0,1,
> ##D                   1,1,0), ncol = 3, nrow = 3, byrow = T)
> ##D #note: the penalty parameters need to be tuned
> ##D wrap.result.sgcca = wrapper.sgcca(data = data, design = design, penalty = c(.3,.5, 1), 
> ##D                                   ncomp = c(2, 2, 1),
> ##D                                   scheme = "centroid", verbose = FALSE)
> ##D 
> ##D select = select.var(wrap.result.sgcca, comp = 1)
> ##D # loading value of the variables selected on the first block
> ##D select$value.var[[1]]
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("select.var", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("sipca")
> ### * sipca
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sipca
> ### Title: Independent Principal Component Analysis
> ### Aliases: sipca
> ### Keywords: algebra
> 
> ### ** Examples
> 
> data(liver.toxicity)
> 
> # implement IPCA on a microarray dataset
> sipca.res <- sipca(liver.toxicity$gene, ncomp = 3, mode="deflation", keepX=c(50,50,50))
> sipca.res

Call:
 sipca(X = liver.toxicity$gene, ncomp = 3, mode = "deflation", keepX = c(50, 50, 50)) 

 Sparse IPCA with 3 independent components. 
 You entered data X of dimensions: 64 3116 
 Selection of 50 50 50 variables on each of the principal components on the X data set. 
 Available components: 
 -------------------- 
 unmixing matrix: see object$unmixing 
 independent principal components: see object$x 
 mxing matrix: see object$mixing 
 kurtosis: see object$kurtosis 
 variable names: see object$names 
 independent loading vectors: see object$loadings 
> 
> # samples representation
> plotIndiv(sipca.res, ind.names = liver.toxicity$treatment[, 4], cex = 0.5, 
+           col = as.numeric(as.factor(liver.toxicity$treatment[, 4])))
Warning in plotIndiv.sipca(sipca.res, ind.names = liver.toxicity$treatment[,  :
  Some of the input arguments do not match the function arguments, see ?plotIndiv
> ## Not run: 
> ##D plot3dIndiv(sipca.res, cex = 0.01,
> ##D             col = as.numeric(as.factor(liver.toxicity$treatment[, 4])))
> ## End(Not run)
> # variables representation
> plotVar(sipca.res, var.label = TRUE, cex = 0.5)
> ## Not run: 
> ##D plot3dVar(sipca.res, rad.in = 0.5, var.label = TRUE, cex = 0.5)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sipca", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("spca")
> ### * spca
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: spca
> ### Title: Sparse Principal Components Analysis
> ### Aliases: spca
> ### Keywords: algebra
> 
> ### ** Examples
> 
> data(liver.toxicity)
> spca.rat <- spca(liver.toxicity$gene, ncomp = 3, keepX = rep(50, 3))
> spca.rat

Call:
 spca(X = liver.toxicity$gene, ncomp = 3, keepX = rep(50, 3)) 

 sparse pCA with 3 principal components. 
 You entered data X of dimensions: 64 3116 
 Selection of 50 50 50 variables on each of the principal components on the X data set. 
 Available components: 
 -------------------- 
 loading vectors: see object$rotation 
 principal components: see object$x 
 cumulative explained variance: see object$varX 
 variable names: see object$names 
> 
> ## variable representation
> plotVar(spca.rat, X.label = TRUE, cex = 0.5)
Warning in plotVar.spca(spca.rat, X.label = TRUE, cex = 0.5) :
  Some of the input arguments do not match the function arguments, see ?plotIndiv
> ## Not run: plot3dVar(spca.rat)
> 
> ## samples representation
> plotIndiv(spca.rat, ind.names = liver.toxicity$treatment[, 3], cex = 0.5, 
+           col = as.numeric(liver.toxicity$treatment[, 3]))
Warning in plotIndiv.pca(spca.rat, ind.names = liver.toxicity$treatment[,  :
  Some of the input arguments do not match the function arguments, see ?plotIndiv
> ## Not run: 
> ##D plot3dIndiv(spca.rat, cex = 0.01, 
> ##D             col = as.numeric(liver.toxicity$treatment[, 3]))
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("spca", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("spls")
> ### * spls
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: spls
> ### Title: Sparse Partial Least Squares (sPLS)
> ### Aliases: spls
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> data(liver.toxicity)
> X <- liver.toxicity$gene
> Y <- liver.toxicity$clinic
> 
> toxicity.spls <- spls(X, Y, ncomp = 2, keepX = c(50, 50), 
+                       keepY = c(10, 10))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("spls", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("splsda")
> ### * splsda
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: splsda
> ### Title: Sparse Partial Least Squares Discriminate Analysis (sPLS-DA)
> ### Aliases: splsda
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> ## First example
> data(breast.tumors)
> X <- breast.tumors$gene.exp
> Y <- breast.tumors$sample$treatment
> 
> res <- splsda(X, Y, ncomp = 2, keepX = c(25, 25))
> palette(c("red", "blue"))
> col.breast <- as.numeric(as.factor(Y))
> plotIndiv(res, ind.names = TRUE, col = col.breast)
> legend('bottomleft', c("After", "Before"), pch = c(16, 16), 
+        col = unique(col.breast), cex = 1, pt.cex = c(1.2, 1.2), 
+        title = "Treatment")
> palette("default")
> 
> ## Second example
> ## Not run: 
> ##D data(liver.toxicity)
> ##D X <- as.matrix(liver.toxicity$gene)
> ##D Y <- liver.toxicity$treatment[, 4]
> ##D 
> ##D splsda.liver = splsda(X, Y, ncomp = 2, keepX = c(20, 20))
> ##D col.rat <- as.numeric(as.factor(Y))
> ##D plotIndiv(splsda.liver, col = col.rat, ind.names = Y)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("splsda", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("summary")
> ### * summary
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: summary
> ### Title: Summary Methods for CCA and PLS objects
> ### Aliases: summary summary.rcc summary.pls summary.spls
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> ## summary for objects of class 'rcc'
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
> more <- summary(nutri.res, cutoff = 0.65)
> 
> ## summary for objects of class 'pls'
> data(linnerud)
> X <- linnerud$exercise
> Y <- linnerud$physiological
> linn.pls <- pls(X, Y)
> more <- summary(linn.pls)
> 
> ## summary for objects of class 'spls'
> data(liver.toxicity)
> X <- liver.toxicity$gene
> Y <- liver.toxicity$clinic
> toxicity.spls <- spls(X, Y, ncomp = 3, keepX = c(50, 50, 50), 
+                       keepY = c(10, 10, 10))
> more <- summary(toxicity.spls, what = "redundancy", keep.var = TRUE)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("summary", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("tune.multilevel")
> ### * tune.multilevel
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tune.multilevel
> ### Title: Tuning functions for multilevel analyses
> ### Aliases: tune.multilevel tune.splsdalevel1 tune.splsdalevel2
> ###   tune.splslevel
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> ## First example: one-factor analysis with sPLS-DA
> ## Not run: 
> ##D data(data.simu) # simulated data
> ##D result.ex1 = tune.multilevel(data.simu$X,
> ##D                                cond = data.simu$stimu,
> ##D                                sample = data.simu$sample, 
> ##D                                ncomp=2,
> ##D                                test.keepX=c(5, 10, 15), 
> ##D                                already.tested.X = c(50),
> ##D                                method = 'splsda',
> ##D                                dist = 'mahalanobis.dist',
> ##D                                validation = 'loo') 
> ##D 
> ##D result.ex1
> ## End(Not run)
> 
> ## Second example: two-factor analysis with sPLS-DA
> ## Not run: 
> ##D data(liver.toxicity)
> ##D dose = liver.toxicity$treatment$Dose.Group
> ##D time = liver.toxicity$treatment$Time.Group
> ##D dose.time = cbind(dose, time)
> ##D repeat.indiv = c(1,2, 1,  2,  1,  2,  1,  2,  3,  3,  4,  
> ##D   3,  4,  3,  4,  4,  5,  6,  5,  5,  6,  5,  6,  7,  7,  
> ##D   8,  6,  7,  8,  7,  8,  8,  9, 10,  9, 10, 11, 9,  9, 
> ##D   10, 11, 12, 12, 10, 11, 12, 11, 12, 13, 14, 13, 14, 13, 
> ##D   14, 13, 14, 15, 16, 15, 16, 15, 16, 15, 16)
> ##D 
> ##D 
> ##D result.ex2 = tune.multilevel (liver.toxicity$gene,
> ##D                                cond = dose.time,
> ##D                                sample = repeat.indiv, 
> ##D                                ncomp=2,
> ##D                                test.keepX=c(5, 10, 15), 
> ##D                                already.tested.X = c(50),
> ##D                                method = 'splsda',
> ##D 			       dist = 'mahalanobis.dist') 
> ##D result.ex2
> ## End(Not run)
> 
> ## Third example: one-factor integrative analysis with sPLS
> ## Not run: 
> ##D result.ex3 = tune.multilevel (liver.toxicity$gene, liver.toxicity$clinic, 
> ##D                                cond = dose,
> ##D                                sample = repeat.indiv, 
> ##D                                ncomp=2,
> ##D                                test.keepX=c(5, 10, 15), 
> ##D                                test.keepY=c(2,3), 
> ##D                                already.tested.X = c(50), already.tested.Y = c(5),
> ##D                                method = 'spls') 
> ##D 
> ##D result.ex3
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tune.multilevel", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("tune.pca")
> ### * tune.pca
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tune.pca
> ### Title: Tune the number of principal components in PCA
> ### Aliases: tune.pca
> ### Keywords: algebra
> 
> ### ** Examples
> 
> data(liver.toxicity)
> tune <- tune.pca(liver.toxicity$gene, center = TRUE, scale = TRUE)
Eigenvalues for the first 10 principal components: 
      PC1       PC2       PC3       PC4       PC5       PC6       PC7       PC8 
874.77885 463.10098 248.15205 167.57834 141.95703 122.32390 108.76499  77.74595 
      PC9      PC10 
 74.18373  56.45566 

Proportion of explained variance for the first 10 principal components: 
       PC1        PC2        PC3        PC4        PC5        PC6        PC7 
0.28073776 0.14862034 0.07963801 0.05377996 0.04555745 0.03925671 0.03490533 
       PC8        PC9       PC10 
0.02495056 0.02380736 0.01811799 

Cumulative proportion explained variance for the first 10 principal components: 
      PC1       PC2       PC3       PC4       PC5       PC6       PC7       PC8 
0.2807378 0.4293581 0.5089961 0.5627761 0.6083335 0.6475902 0.6824956 0.7074461 
      PC9      PC10 
0.7312535 0.7493715 

(for all principal components, see object$var, object$prop.var and object$cum.var)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tune.pca", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("tune.rcc")
> ### * tune.rcc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tune.rcc
> ### Title: Estimate the parameters of regularization for Regularized CCA
> ### Aliases: tune.rcc tune.rcc.default
> ### Keywords: multivariate dplot
> 
> ### ** Examples
> 
> data(nutrimouse)
> X <- nutrimouse$lipid
> Y <- nutrimouse$gene
> 
> ## this can take some seconds
> ## Not run: 
> ##D tune.rcc(X, Y, validation = "Mfold")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tune.rcc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("vip")
> ### * vip
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: vip
> ### Title: Variable Importance in the Projection (VIP)
> ### Aliases: vip
> ### Keywords: regression multivariate
> 
> ### ** Examples
> 
> data(linnerud)
> X <- linnerud$exercise
> Y <- linnerud$physiological
> linn.pls <- pls(X, Y)
> 
> linn.vip <- vip(linn.pls)
> 
> barplot(linn.vip,
+         beside = TRUE, col = c("lightblue", "mistyrose", "lightcyan"),
+         ylim = c(0, 1.7), legend = rownames(linn.vip),
+         main = "Variable Importance in the Projection", font.main = 4)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("vip", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("wrapper.rgcca")
> ### * wrapper.rgcca
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: wrapper.rgcca
> ### Title: mixOmics wrapper for Regularised Generalised Canonical
> ###   Correlation Analysis (rgcca)
> ### Aliases: wrapper.rgcca
> ### Keywords: multivariate
> 
> ### ** Examples
> 
> data(nutrimouse)
> # need to unmap the Y factor diet
> Y = unmap(nutrimouse$diet)
> data = list(nutrimouse$gene, nutrimouse$lipid,Y)
> # with this design, gene expression and lipids are connected to the diet factor
> # design = matrix(c(0,0,1,
> #                   0,0,1,
> #                   1,1,0), ncol = 3, nrow = 3, byrow = TRUE)
> 
> # with this design, gene expression and lipids are connected to the diet factor
> # and gene expression and lipids are also connected
> design = matrix(c(0,1,1,
+                   1,0,1,
+                   1,1,0), ncol = 3, nrow = 3, byrow = TRUE)
> #note: the tau parameter is the regularization parameter
> wrap.result.rgcca = wrapper.rgcca(data = data, design = design, tau = c(1, 1, 0), 
+                                   ncomp = c(2, 2, 1),
+                                   scheme = "centroid", verbose = FALSE)
> #wrap.result.rgcca
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("wrapper.rgcca", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("wrapper.sgcca")
> ### * wrapper.sgcca
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: wrapper.sgcca
> ### Title: mixOmics wrapper for Sparse Generalised Canonical Correlation
> ###   Analysis (sgcca)
> ### Aliases: wrapper.sgcca
> ### Keywords: multivariate
> 
> ### ** Examples
> 
> data(nutrimouse)
> # need to unmap the Y factor diet
> Y = unmap(nutrimouse$diet)
> data = list(nutrimouse$gene, nutrimouse$lipid,Y)
> # with this design, gene expression and lipids are connected to the diet factor
> # design = matrix(c(0,0,1,
> #                   0,0,1,
> #                   1,1,0), ncol = 3, nrow = 3, byrow = TRUE)
> 
> # with this design, gene expression and lipids are connected to the diet factor
> # and gene expression and lipids are also connected
> design = matrix(c(0,1,1,
+                   1,0,1,
+                   1,1,0), ncol = 3, nrow = 3, byrow = TRUE)
> 
> #note: the penalty parameters will need to be tuned
> wrap.result.sgcca = wrapper.sgcca(data = data, design = design, penalty = c(.3,.5, 1), 
+                                   ncomp = c(2, 2, 1),
+                                   scheme = "centroid", verbose = FALSE)
> wrap.result.sgcca

Call:
 sgcca(data = data, design = design, penalty = c(0.3, 0.5, 1), ncomp = c(2, 2, 1), scheme = "centroid", verbose = FALSE) 

 sGCCA with 2 components on block 1 
 sGCCA with 2 components on block 2 
 sGCCA with 1 components on block 3 

 Dimension of block 1 is  40 120 
 Dimension of block 2 is  40 21 
 Dimension of block 3 is  40 5 

 Selection of 15 19 variables on each of the sGCCA components on the block 1 
 Selection of 7 7 variables on each of the sGCCA components on the block 2 
 Selection of 5 variables on each of the sGCCA components on the block 3 

 Available components: 
 -------------------- 
 loading vectors: see object$loadings 
 variates: see object$variates 
 variable names: see object$names 
> #did the algo converge?
> wrap.result.sgcca$crit  # yes
[[1]]
 [1] 12.65312 13.66825 14.55752 14.76009 14.78409 14.78913 14.79012 14.79035
 [9] 14.79039 14.79041 14.79041 14.79041 14.79041 14.79041 14.79041 14.79041
[17] 14.79041 14.79041 14.79041 14.79041 14.79041 14.79041 14.79041 14.79041
[25] 14.79041 14.79041 14.79041 14.79041

[[2]]
 [1] 13.57478 13.98891 14.05377 14.07328 14.07878 14.08000 14.08026 14.08031
 [9] 14.08033 14.08033 14.08033 14.08033 14.08033 14.08033 14.08033 14.08033
[17] 14.08033 14.08033 14.08033 14.08033 14.08033 14.08033 14.08033 14.08033
[25] 14.08033 14.08033

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("wrapper.sgcca", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  25.026 0.823 25.96 0.001 0.001 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
