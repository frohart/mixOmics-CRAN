---
title: "Diablo_TCGA"
author: "Kim-Anh Lê Cao, Florian Rohart, Danielle Davenport"
date: "9 August 2017"
output:
  html_document:
    code_folding: show
    highlight: haddock
    df_print: kable
---

```{r global_options, include=FALSE}
library(knitr)
knitr::opts_chunk$set(dpi = 100, echo= TRUE, warning=FALSE, message=FALSE, #dev = 'jpeg',
                      fig.show=TRUE, fig.keep = 'all', fig.height= 8, fig.width=9)
```

# N-Integration discriminant analysis with Diablo

Human breast cancer is a heterogeneous disease in terms of molecular alterations, cellular composition, and clinical outcome. Breast tumors can be classified into several sub types, according to levels of mRNA expression (Sørlie et al., 2001 [1]). Here we consider a subset of data generated by The Cancer Genome Atlas Network (Network et al., 2012 [2]). Data were normalized and drastically pre-filtered for illustrative purposes. The data were divided into a training set with a subset of 150 samples from the mRNA, miRNA and proteomics data, and a test set includes 70 samples, but only from the mRNA, miRNA and methylation data (proteomics missing). The **aim of our N-integration analysis is to identify a highly correlated multi-‘omics signature discriminating the breast cancer subtypes subgroups Basal, Her2 and LumA**.

The full data set for this example (also including methylation data and 4 breast cancer subtypes) can be downloaded [here](http://mixomics.org/wp-content/uploads/2016/08/TCGA.normalised.mixDIABLO.RData_.zip). In the example below illustrate an analysis on a smaller data set that is stored in the mixOmics package. 

Load the latest version of [mixOmics](https://cran.r-project.org/web/packages/mixOmics/index.html) (chek the version!).

```{r}
library(mixOmics)
```


# Data

## Data preparation

The data for mixDIABLO need to be set up as a list of data matrices matching the same samples. The **blocks:** are 'omics data sets, where each row matches to the same biological sample from one data set to another. The outcome Y is set as a factor for the supervised analysis. Here Y corresponds to the PAM50 classification.

The data for *DIABLO* need to be set up as a list of data matrices matching the same samples in rows.

```{r}
data('breast.TCGA')
# extract training data
data = list(mrna = breast.TCGA$data.train$mrna, 
            mirna = breast.TCGA$data.train$mirna, 
            prot = breast.TCGA$data.train$protein)

# check dimension
lapply(data, dim)

# outcome is a factor
Y = breast.TCGA$data.train$subtype
summary(Y)
```


# Parameter choice

## Design
The matrix *design* determines which blocks should be connected to maximize the correlation or covariance between components. the values may range between 0 (no correlation) to 1 (correlation to maximize) and is a symmetrical matrix. The design can be chosen based on prior knowledge (‘I expect mRNA and miRNA to be highly correlated’) or data-driven (e.g. based on a prior analysis, such as a non sparse analysis with block.pls to examine the correlation between the different blocks via the modelled components). 
Our experience has shown that a compromise between maximising the correlation between blocks, and discriminating the outcome needed to be achieved, and that the weight in the design matrix could be set to < 1 between blocks (see an example in our vignette and information in supplemental material in [4]).

Here we choose a design where all the blocks are connected with a link of 0.1 (see Supplemental Information S3). We set the number of components to K-1, where K is the number of categories in the Y outcome.

```{r}
ncomp = 2
design = matrix(0.1, ncol = length(data), nrow = length(data), 
                dimnames = list(names(data), names(data)))
diag(design) = 0

design 
```

## Tuning the number of components
First, we fit a DIABLO model without variable selection to assess the global performance and choose the number of components for the final DIABLO model. The function **perf** is run with 5-fold cross validation repeated 10 times. 


```{r}
sgccda.res = block.splsda(X = data, Y = Y, ncomp = 5, 
                           design = design)

set.seed(123) # for reproducibility, only when the `cpus' argument is not used
perf.diablo = perf(sgccda.res, validation = 'Mfold', M = 5, nrepeat = 10)

#perf.diablo  # lists the different outputs
plot(perf.diablo) # from the $WeightedVote.error.rate output
```

From the performance plot above we observe that both overall and balanced error rate (BER) decrease from 1 to 2 components. The standard deviation indicates a potential slight gain in adding more components. The centroids.dist distance seem to give the best accuracy (see Supplemental Material \citep{Roh17}). Considering this distance and the BER, the output **$choice.ncomp** indicates an optimal number of components for the final DIABLO model.


```{r}
##perf.diablo$choice.ncomp$WeightedVote
ncomp = 2##perf.diablo$choice.ncomp$WeightedVote["Overall.BER", "centroids.dist"]
```


## Tuning keepX

This tuning function should be used to tune the **keepX** parameters in the *block.splsda* function. 

We choose the optimal number of variables to select in each data set using the *tune* function, for a grid of **keepX** values. Note that the function has been set to favor the small-ish signature while allowing to obtain a sufficient number of variables for downstream validation / interpretation. See *?tune.block.splsda*.

We choose the optimal number of variables to select in each data set using the *tune.block.splsda* function, to which we provide a grid of **keepX** values for each type of `omics. Note that the function has been set to favour the small-ish signature while allowing to obtain a sufficient number of variables for downstream validation / interpretation.

The function **tune** is run with 5-fold cross validation, but repeated only once. Note that for a more thorough tuning process, provided sufficient computational time, we could increase the **nrepeat** argument.


```{r, eval=FALSE, include = FALSE}
#set.seed(123) # for reproducibility, only when the `cpus' argument is not used
test.keepX = list ("mRNA" = c(5:9, seq(10, 18, 2), seq(20,30,5)),
                   "miRNA" = c(5:9, seq(10, 18, 2), seq(20,30,5)),
                   "proteomics" = c(5:9, seq(10, 18, 2), seq(20,30,5)))

t1 = proc.time()
tune.TCGA = tune.block.splsda(X = data, Y = Y, ncomp = ncomp, 
                              test.keepX = test.keepX, design = design,
                              validation = 'Mfold', M = 5, nrepeat = 1,
                              cpus = 2, dist = "centroids.dist")
t2 = proc.time()
running_time = t2 - t1; running_time

list.keepX = tune.TCGA$choice.keepX
list.keepX

save(tune.TCGA,list.keepX, running_time, file = 'RData/result-TCGA-diablo_design0.1.RData')
```



```{r, include =TRUE, eval=FALSE}
test.keepX = list ("mRNA" = c(5:9, seq(10, 18, 2), seq(20,30,5)),
                   "miRNA" = c(5:9, seq(10, 18, 2), seq(20,30,5)),
                   "proteomics" = c(5:9, seq(10, 18, 2), seq(20,30,5)))
t1 = proc.time()
tune.TCGA = tune.block.splsda(X = data, Y = Y, ncomp = ncomp, 
                              test.keepX = test.keepX, design = design, 
                              validation = 'Mfold', M = 5, nrepeat = 1, 
                              dist = "centroids.dist", cpus = 2)
t2 = proc.time()
running_time = t2 - t1; running_time

list.keepX = tune.TCGA$choice.keepX
list.keepX
```

The number of features to select on each component is returned in **tune.TCGA$choice.keepX**. Alternatively, you can manually input those parameters as indicated below.


```{r, include =FALSE, eval=TRUE}
load('RData/result-TCGA-diablo_design0.1.RData')
list.keepX = tune.TCGA$choice.keepX
tune.TCGA$choice.keepX
```

```{r}
list.keepX = list("mrna" = c(6,14), "mirna" = c(5,18), "prot" = c(6,7)) # from tuning step
```


# Final model

The final **DIABLO** model is run as:

```{r}
sgccda.res = block.splsda(X = data, Y = Y, ncomp = ncomp, 
                          keepX = list.keepX, design = design)
#sgccda.res   # list the different functions of interest related to that object
```

The warning message informs that the outcome Y has been included automatically in the design, so that the covariance between each block's component and the outcome is maximised, as shown in the final design output

```{r}
sgccda.res$design
```

The selected variables can be extracted with the function *selectVar*, for example in the mRNA block:

```{r}
# mrna variables selected on component 1
selectVar(sgccda.res, block = 'mrna', comp = 1)$mrna$name 
```

# Sample plots

*plotDIABLO* is a diagnostic plot to check whether the correlation between components from each data set has been maximized as specified in the design matrix. We specify which dimension to be assessed with the **ncomp** argument.

```{r}
plotDiablo(sgccda.res, ncomp = 1)
```

The first components from each data set are highly correlated to each other. The colors and ellipses related to the sample subtypes and indicate the discriminative power of each component to separate the different tumour subtypes.


The sample plot with the **plotIndiv** function projects each sample into the space spanned by the components of each block. The optional argument **blocks** can output a specific data set. Ellipse plots are also available (argument **ellipse = TRUE**):

```{r}
plotIndiv(sgccda.res, ind.names = FALSE, legend = TRUE, title = 'DIABLO')
```

In the arrow plot below, the start of the arrow indicates the centroid between all data sets for a given sample and the tips of the arrows the location of that sample in each block. Such graphic highlight the agreement between all data sets at the sample level, when modelled with **DIABLO**.

```{r}
plotArrow(sgccda.res, ind.names = FALSE, legend = TRUE, title = 'DIABLO')
```


# Variable plots

Several graphical outputs are available to visualize and mine the associations between the selected variables. 

The correlation circle plot highlights the contribution of each selected variable to each component, see [3]. **plotVar**  displays the variables from all blocks, selected on component 1 and 2 (see [here](http://mixomics.org/graphics/sample-plot/plotvar/) for more examples). Clusters of points indicate a strong correlation between variables. For better visibility we choose to hide the variable names:

```{r}
plotVar(sgccda.res, var.names = FALSE, style = 'graphics', legend = TRUE, 
        pch = c(16, 17, 15), cex = c(2,2,2), col = c('darkorchid', 'brown1', 'lightgreen'))
```

The circos plot represents the correlations between variables of different types, represented on the side quadrants. Several display options are possible, to show within and between connexions between blocks, expression levels of each variable according to each class (argument *line = TRUE*). The circos plot is built based on a similarity matrix, extended to the case of multiple data sets from [3].

```{r}
circosPlot(sgccda.res, cutoff = 0.7, line = TRUE, 
           color.blocks= c('darkorchid', 'brown1', 'lightgreen'),
           color.cor = c("chocolate3","grey20"), size.labels = 1.5)
```


Another visualisation of the correlation between the different types of variables is the relevance network, which is also built on the similarity matrix. Each color represents a type of variable. A threshold can also be set using the argument **cutoff**.

Note that sometimes the output may not show with Rstudio because of margin issues. The plot can be saved as an image using the argument **save** and **name.save**. An **interactive** argument is also available for the **cutoff** argument, see details in **?network**.




```{r}
network(sgccda.res, blocks = c(1,2,3),
        color.node = c('darkorchid', 'brown1', 'lightgreen'), cutoff = 0.4)
```


The network can be saved in a .gml format to be input into the software Cytoscape, using the R package igraph
```{r eval = FALSE}
# not run
library(igraph)
my.network = network(sgccda.res, blocks = c(1,2,3),
        color.node = c('darkorchid', 'brown1', 'lightgreen'), cutoff = 0.4)
write.graph(my.network$gR, file = "myNetwork.gml", format = "gml")
```


**plotLoadings()** visualizes the loading weights of each selected variables on each component and each data set. The color indicates the class in which the variable has the maximum level of expression (*contrib = 'max'*), on average (*method = 'mean'*) or using the median (*method = 'median'*).

```{r}
plotLoadings(sgccda.res, comp = 2, contrib = 'max', method = 'median')
```

The *cimDIABLO()* function is a clustered image map specifically implemented to represent the multi-`omics molecular signature expression for each sample. 

```{r}
cimDiablo(sgccda.res)
```



# Performance of the model 
We assess the performance of the model using 10-fold cross-validation repeated 10 times, using the function **perf**. The method runs a **block.splsda** model on the pre-specified arguments input from our **sgccda.res** object but on cross-validated samples. We then assess the accuracy of the prediction on the left out samples. 

In addition to the usual (balanced) classification error rates, predicted scores and stability of the selected features, **perf** for DIABLO outputs the performance based on Majority Vote (each data set votes for a class for a particular test sample) or the Average Prediction (the prediction scores - which are continuous values averaged across all data sets).
Note that since the **tune** function was used with the **max.dist** argument, the most appropriate outputs of **pref** are the ones relative to this distance.



```{r}
set.seed(123)# for reproducibility
perf.diablo = perf(sgccda.res, validation = 'Mfold', M = 10, nrepeat = 10)
#perf.diablo  # lists the different outputs

# Performance with Majority vote
perf.diablo$MajorityVote.error.rate

# Performance with Weighted prediction
perf.diablo$WeightedVote.error.rate
```

In addition to the usual (balanced) classification error rates, predicted dummy variables and variates, as well as stability of the selected features, the **perf** function for DIABLO outputs the performance based on Majority Vote (each data set votes for a class for a particular test sample) or a weighted vote, where the weight is defined according to the correlation between the latent component associated to a particular data set and the outcome. 

Since the **tune** function was used with the **centroid.dist** argument, we examine the outputs of the **perf** function for that same distance. 

An AUC plot per block can also be obtained using the function **auroc**.

```{r}
auc.splsda = auroc(sgccda.res, roc.block = "miRNA", roc.comp = 2)
```



# Prediction on an external test set
The **predict** function predicts the class of samples from a test set. In our specific case, one data set is missing in the test set but the method can still be applied. 

```{r}
# prepare test set data: here one block (proteins) is missing
data.test.TCGA = list(mRNA = breast.TCGA$data.test$mrna, 
                      miRNA = breast.TCGA$data.test$mirna)

predict.diablo = predict(sgccda.res, newdata = data.test.TCGA)
# the warning message will inform us that one block is missing
#predict.diablo # list the different outputs
```


The confusion table compares the real subtypes with the predicted subtypes for a 2 component model, for the distance of interest:

```{r}
confusion.mat = get.confusion_matrix(truth = breast.TCGA$data.test$subtype, 
                     predicted = predict.diablo$WeightedVote$centroids.dist[,2])
confusion.mat
get.BER(confusion.mat)
```

# Session information of this code
```{r}
sessionInfo()
```


# More details?
Have a look at our reference [4] and [5] and the supplemental of [5] in particular!

# Reference

1. [Sørlie T, Perou CM, Tibshirani R, Aas T, Geisler S, Johnsen H, Hastie T, Eisen MB, Van De Rijn M, Jeffrey SS, et al. Gene expression patterns of breast carcinomas distinguish tumor subclasses with clinical implications. Proceedings of the National Academy of Sciences, 98(19):10869–10874, 2001.](https://scholar.google.com/scholar_url?url=http://www.pnas.org/content/98/19/10869.long&hl=en&sa=T&oi=gsb-gga&ct=res&cd=0&ei=EKpHWPa4OMaL2Abn-JiICQ&scisig=AAGBfm2tNmF6Q30lJImI_8A8TEZK6M48fw)

2. [Cancer Genome Atlas Network et al. Comprehensive molecular portraits of human breast tumours. Nature, 490(7418):61–70, 2012.](https://scholar.google.com/scholar_url?url=http://www.nature.com/nature/journal/v490/n7418/full/nature11412.html&hl=en&sa=T&oi=gsb-gga&ct=res&cd=0&ei=_6lHWI_6LZCSjAGQgK_IBQ&scisig=AAGBfm0mbkuwHpxS7HHsdS-Ox8O56y9BBA)

3. [Gonzalez, I, Le Cao, K.A., Davis, M.J. and Dejean, S., 2012. Visualising associations between paired ‘omics’ data sets. BioData mining, 5(1)](https://scholar.google.com/scholar_url?url=http://biodatamining.biomedcentral.com/articles/10.1186/1756-0381-5-19&hl=en&sa=T&oi=gsb-gga&ct=res&cd=0&ei=H6pHWNnkBIK3jAH_urXIDA&scisig=AAGBfm3KMZrTEHwP7F7-3VbbPowlBMeYiQ)

4. [Singh, A, Gautier, B, Shannon, CP, Vacher, M, Rohart, F, Tebutt, SJ. and Le Cao, KA, 2016. DIABLO-an integrative, multi-omics, multivariate method for multi-group classification. bioRxiv, p.067611.](https://scholar.google.com/scholar_url?url=http://www.biorxiv.org/content/biorxiv/early/2016/08/03/067611.full.pdf&hl=en&sa=T&oi=gsb-gga&ct=res&cd=0&ei=9PJFWKrBEZCxmAGFmYKQBg&scisig=AAGBfm3iG_i1eg3qvaDrd8JOciOvicXIRw)

5. [Rohart F,  Gautier, B, Singh, A and Lê Cao, KA. mixOmics: an R package for ‘omics feature selection and multiple data integration.](http://biorxiv.org/content/early/2017/02/14/108597) On bioRxiv. [Pdf, Sweave and R scripts available here](http://mixomics.org/wp-content/uploads/2012/03/mixOmicsRscripts.zip).

6. [Rohart F, Mason EA, Matigian N, Mosbergen R, Korn O, Chen T, Butcher S, Patel J, Atkinson K, Khosrotehrani K, Fisk NM, Lê Cao K-A&, Wells CA& (2016). A Molecular Classification of Human Mesenchymal Stromal Cells, PeerJ 4:e1845](https://peerj.com/articles/1845/)


