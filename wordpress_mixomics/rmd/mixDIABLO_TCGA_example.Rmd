---
title: "mixDiablo_TCGA_Example"
author: "Danielle Davenport"
date: "7 December 2016"
output:
  html_document:
    code_folding: show
    highlight: haddock
    df_print: kable
---

```{r global_options, include=FALSE}
library(knitr)
knitr::opts_chunk$set(dpi = 100, echo= TRUE, warning=FALSE, message=FALSE, #dev = 'jpeg',
                      fig.show=TRUE, fig.keep = 'all', fig.height= 8, fig.width=9)
```

# N-Integration discriminate analysis with mixDiablo

Human breast cancer is a heterogeneous disease in terms of molecular alterations, cellular composition, and clinical outcome. Breast tumors can be classified into several sub types, according to levels of mRNA expression (Sørlie et al., 2001). Here we consider a subset of data generated by The Cancer Genome Atlas Network (Network et al., 2012). Data were normalized and drastically pre-filtered for illustrative purposes. The data were divided into a training set with a subset of 150 samples from the mRNA, miRNA and proteomics data, and a test set includes 70 samples, but only from the mRNA, miRNA and methylation data (proteomics missing). The **aim** of the N-integration analysis is to identify a highly correlated multi-‘omics signature discriminating the breast cancer subtypes subgroups Basal, Her2 and LumA.

The full data set for this example (also including methylation data and 4 breast cancer subtypes) can be downloaded [here](http://mixomics.org/mixdiablo/data/). Below we show a smaller example that is stored in the package. The data for mixDIABLO need to be set up as a list of data matrices matching the same samples in rows (**blocks:** `omics data sets, each row should match to the same biological sample from one data set to another) and the outcome (PAM50) Y as a factor.

## To begin...
Load the latest version of [mixOmics](https://www.rdocumentation.org/link/%20www.mixOmics.org%2FmixMC?package=mixOmics&version=6.0.0).

```{r}
library(mixOmics)
```

```{r}
data('breast.TCGA')
# extract training data
data = list(mrna = breast.TCGA$data.train$mrna, 
            mirna = breast.TCGA$data.train$mirna, 
            prot = breast.TCGA$data.train$protein)

# check dimension
lapply(data, dim)

# outcome
Y = breast.TCGA$data.train$subtype
summary(Y)
```


# Parameter choice
The matrix *design* determines which blocks should be connected to maximize the correlation or co variance between components.  It can only take the value 0 (no correlation) or 1 (correlation to maximize) and is a symmetrical matrix. The design can be chosen based on prior knowledge (‘I expect mRNA and miRNA to be highly correlated’) or data-driven.

Here we choose a 'full' design, where all blocks are connected. We set the number of components to K-1, where K is the number of categories in the **Y** outcome.

```{r}
ncomp = 2
design = matrix(1, ncol = length(data), nrow = length(data), dimnames = list(names(data), names(data)))
diag(design) = 0
design 
```

# Tuning 

This tuning function should be used to tune the **keepX** parameters in the *block.splsda* function. 

We choose the optimal number of variables to select in each data set using the **tune()** function, for a grid of *keepX* values. Note that the function has been set to favor the small-ish signature while allowing to obtain a sufficient number of variables for downstream validation / interpretation. See **?tune.block.splsda**.


```{r, eval=FALSE, include = FALSE}
test.keepX = list ("mrna" = c(5:9, seq(10, 18, 2), seq(20,30,5)),
                   "mirna" = c(5:9, seq(10, 18, 2), seq(20,30,5)),
                   "prot" = c(5:9, seq(10, 18, 2), seq(20,30,5)))


tune.TCGA = tune.block.splsda(X = data, Y = Y, ncomp = ncomp, 
                              test.keepX = test.keepX, design = design, cpus = 2)

list.keepX = tune.TCGA$choice.keepX
```

```{r, include =FALSE, eval=FALSE}
save(tune.TCGA,list.keepX, file = 'RData/result-TCGA-diablo-light.RData')
```

```{r, eval=FALSE}
test.keepX = list ("mrna" = c(5:9, seq(10, 18, 2), seq(20,30,5)),
                   "mirna" = c(5:9, seq(10, 18, 2), seq(20,30,5)),
                   "prot" = c(5:9, seq(10, 18, 2), seq(20,30,5)))
tune.TCGA = tune.block.splsda(X = data, Y = Y, ncomp = ncomp, 
                              test.keepX = test.keepX, design = design)
```


```{r, include=FALSE}
load('RData/result-TCGA-diablo-light.RData')
```


```{r}
list.keepX = list("mrna" = c(7,12), "mirna" = c(5,25), "prot" = c(5,16)) # from tuning step
```


# sPLS-DA Model

The final **mixDIABLO** model is run as:

```{r}
sgccda.res = block.splsda(X = data, Y = Y, ncomp = ncomp, keepX = list.keepX, design = design)
#sgccda.res   # list the different functions of interest related to that object
```

The warning message informs that the outcome Y has been included automatically in the design, so that the co variance between each block's component and the outcome is maximized, as shown in the final design output:

```{r}
sgccda.res$design
```

The selected variables can be extracted with the function **selectVar()**, for example in the mRNA block:

```{r}
# mrna variables selected on component 1
selectVar(sgccda.res, block = 'mrna', comp = 1)$mrna$name 
```

# Sample plots

**plotDIABLO** is a diagnostic plot to check whether the correlation between components of each data set has been maximized as specified in the design matrix. We specify which dimension to be assessed with the *ncomp* argument.

```{r}
plotDiablo(sgccda.res, ncomp = 1)
```

The first components from each data set are highly correlated to each others. The colors and ellipses related to the sample sub types and indicate the discriminating power of each component to separate the different tumor sub types.


The sample plot with the **plotIndiv** function projects each sample into the space spanned by the components of each block. The optional argument **blocks** can output a specific data set. Ellipse plots are also available (argument **ellipse = TRUE**):

```{r}
plotIndiv(sgccda.res, ind.names = FALSE, legend = TRUE, title = 'DIABLO')
```

In the arrow plot below, the start of the arrow indicates the centroid between all data sets for a given sample and the tips of the arrows the location of that sample in each block. Such graphic highlight the agreement between all data sets at the sample level, when modeled with DIABLO.

```{r}
plotArrow(sgccda.res, ind.names = FALSE, legend = TRUE, title = 'DIABLO')
```


# Variable plots

Several graphical outputs are available to visualize and mine the associations between the selected variables. 

The correlation circle plot highlights the contribution of each selected variable to each component, see [3]. **plotVar**  displays the variables from all blocks, selected on component 1 and 2 (see [here](http://mixomics.org/graphics/sample-plot/plotvar/) for more examples). Clusters of points indicate a strong correlation between variables. For better visibility we choose to hide the variable names:

```{r}
plotVar(sgccda.res, var.names = FALSE, style = 'graphics', legend = TRUE, 
        pch = c(16, 17, 15), cex = c(2,2,2), col = c('blue', 'red2', 'darkgreen'))
```

The circos plot represents the correlations between variables of different types, represented on the side quadrants. Several display options are possible, to show within and between connexions between blocks, expression levels of each variable according to each class (argument *line = TRUE*). The circos plot is built based on a similarity matrix, extended to the case of multiple data sets from [3].

```{r}
circosPlot(sgccda.res, cutoff = 0.7, line = FALSE)
```


Another visualization of the correlation between the different types of variables is the relevance network, that is also built on the similarity matrix. Each color represents a type of variable.

```{r}
network(sgccda.res, blocks = c(1,2,3), cex.node.name = 0.6, 
        color.node = c('lightblue', 'red2', 'lightgreen'))
```

**plotLoadings()*** visualizes the loading weights of each selected variables on each component and each data set. The color indicates the class in which the variable has the maximum level of expression (*contrib = 'max'*), on average (*method = 'mean'*) or using the median (*method = 'median'*).

```{r}
plotLoadings(sgccda.res, comp = 2, contrib = 'max', method = 'median')
```

The *cimDIABLO()* function is a clustered image map specifically implemented to represent the multi-`omics molecular signature expression for each sample. 

```{r}
cimDiablo(sgccda.res)
```



# Performance of the model 

We assess the performance of the model using 10 x 10-fold cross-validation using the function **perf()**. The method runs a *block.splsda* model on the pre-specified arguments input from our *sgccda.res* object but on cross-validated samples. We then assess the accuracy of the prediction on the left out samples. 

In addition to the usual (balanced) classification error rates, predicted scores and stability of the selected features, **perf()** for DIABLO outputs the performance based on Majority Vote (each data set votes for a prediction for a particular test sample) or the Average Prediction (the prediction scores are continuous values averaged across all data sets). 

```{r}
perf.diablo = perf(sgccda.res, validation = 'Mfold', M = 10, 
                   dist = 'mahalanobis.dist', nrepeat = 10)
#perf.diablo  # lists the different outputs

# Performance with Majority vote
kable(perf.diablo$MajorityVote.error.rate)

# Performance with Weighted prediction
kable(perf.diablo$WeightedPredict.error.rate)
```

# Prediction on an external test set
The **predict()** function predicts the class of samples from a test set. In our specific case on data set is missing in the test set.

```{r}
# prepare test set data: here one block (proteins) is missing
data.test.TCGA = list(mrna = breast.TCGA$data.test$mrna, 
                      mirna = breast.TCGA$data.test$mirna)

predict.diablo = predict(sgccda.res, newdata = data.test.TCGA, dist = 'mahalanobis.dist')
# the warning message will inform us that one block is missing
#predict.diablo # list the different outputs

# the confusion table compares the real subtypes with the predicted subtypes for a 2 component model
table(predict.diablo$MajorityVote$mahalanobis.dist[,2], breast.TCGA$data.test$subtype)
```


# Reference

1. [Therese Sørlie, Charles M Perou, Robert Tibshirani, Turid Aas, Stephanie Geisler, Hilde Johnsen, Trevor Hastie, Michael B Eisen, Matt Van De Rijn, Stefanie S Jeffrey, et al. Gene expression patterns of breast carcinomas distinguish tumor subclasses with clinical implications. Proceedings of the National Academy of Sciences, 98(19):10869–10874, 2001.](https://scholar.google.com/scholar_url?url=http://www.pnas.org/content/98/19/10869.long&hl=en&sa=T&oi=gsb-gga&ct=res&cd=0&ei=EKpHWPa4OMaL2Abn-JiICQ&scisig=AAGBfm2tNmF6Q30lJImI_8A8TEZK6M48fw)

2. [Cancer Genome Atlas Network et al. Comprehensive molecular portraits of human breast tumours. Nature, 490(7418):61–70, 2012.](https://scholar.google.com/scholar_url?url=http://www.nature.com/nature/journal/v490/n7418/full/nature11412.html&hl=en&sa=T&oi=gsb-gga&ct=res&cd=0&ei=_6lHWI_6LZCSjAGQgK_IBQ&scisig=AAGBfm0mbkuwHpxS7HHsdS-Ox8O56y9BBA)

3. [Gonzalez, I., Le Cao, K.A., Davis, M.J. and Dejean, S., 2012. Visualising associations between paired ‘omics’ data sets. BioData mining, 5(1), p.1.https://scholar.google.com/scholar_url?url=http://biodatamining.biomedcentral.com/articles/10.1186/1756-0381-5-19&hl=en&sa=T&oi=gsb-gga&ct=res&cd=0&ei=H6pHWNnkBIK3jAH_urXIDA&scisig=AAGBfm3KMZrTEHwP7F7-3VbbPowlBMeYiQ)

4. [Singh, A., Gautier, B., Shannon, C.P., Vacher, M., Rohart, F., Tebutt, S.J. and Le Cao, K.A., 2016. DIABLO-an integrative, multi-omics, multivariate method for multi-group classification. bioRxiv, p.067611.](https://scholar.google.com/scholar_url?url=http://www.biorxiv.org/content/biorxiv/early/2016/08/03/067611.full.pdf&hl=en&sa=T&oi=gsb-gga&ct=res&cd=0&ei=9PJFWKrBEZCxmAGFmYKQBg&scisig=AAGBfm3iG_i1eg3qvaDrd8JOciOvicXIRw)